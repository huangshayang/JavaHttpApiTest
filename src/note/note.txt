1.参数的类型不同，个数不同，在不改动代码结构的前提下，通过将某个参数的类型转换成需要的类型即可

2.hashmap是无序的

3.构造方法通过builder模式来创建，比写多个构造方法要更高效
方法：一个要执行的类，里面包含私有属性，并创建私有的构造方法（赋值），其中构造方法里传入外部类的实例对象，再创建一个内部静态类,定义外部类的实例，并创建静态内部类的public构造方法，并在构造方法里实例化外部类的实例，在构造方法里定义需要每次调用必须传的对象，给外部类的实例对象属性赋值，再创建后续需要调用的方法，最后在内部类创建类型为外部类的public build方法，返回值为外部类对象，并传入外部类的实例

4.
String：字符串常量。String对象一旦产生后就不可以被修改，重新赋值其实是两个对象,因为操作的是引用，并不是对象本身。

StringBuffer：字符串变量

StringBuilder：字符串变量
StringBuffer对象的内容可以修改
StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。StringBuilder是线程不安全的
执行速度方面的比较：StringBuilder >  StringBuffer  >  String

5.File[]数组里，要存放file应该以new File(path)

6.程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成

在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成

7.字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！
如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点
在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。

8.excel的操作用
<dependency>
 <groupId>org.apache.poi</groupId>
 <artifactId>poi</artifactId>
 <version>3.17-beta1</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml -->
<dependency>
 <groupId>org.apache.poi</groupId>
 <artifactId>poi-ooxml</artifactId>
 <version>3.17-beta1</version>
</dependency>
这两个lib
基本的操作：
File file = new File(System.getProperty("user.dir") + "\\src\\main\\java\\com\\hsy\\case\\" + casePath);
FileInputStream fileInputStream = new FileInputStream(file);
XSSFWorkbook xssfWorkbook = new XSSFWorkbook(fileInputStream);
xssfWorkbook.getSheetAt(i)这个返回当前的sheet
xssfWorkbook.getSheetAt(i).getLastRowNum()返回当前sheet的总行数
xssfWorkbook.getSheetAt(i).getLastRowNum(j).getCell(k)返回第j行第k个单元格的值
在操作单元格的时候，会因为单元格为空出现NullPointException，加入判断cell == null就好

9.static关键字的作用：修饰变量，常量，方法，代码块，静态内部类，静态包导入。
其中，静态代码块：JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次
静态代码块优先于构造函数执行

10.ArrayList：
底层是数组实现；
3种构造方法
在添加时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容

ArrayList不是线程安全的，只能用在单线程环境下，同样的实现Vector的方法前加了关键字synchronized
多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，List list = Collections.synchronizedList(new ArrayList());

Vector和Collections.synchronizedList区别：
（1）Vector比Collections.synchronizedList快了一点，SynchronizedList<E>类使用了委托(delegation)，实质上存储还是使用了构造时传进来的list，只是将list作为底层存储，对它做了一层包装
（2）SynchronizedList的同步，使用的是synchronized代码块对mutex对象加锁，这个mutex对象还能够通过构造函数传进来，也就是说我们可以指定锁定的对象
而Vector则使用了synchronized方法，同步方法的作用范围是整个方法，所以没办法对同步进行细粒度的控制。而且同步方法加锁的是this对象，没办法控制锁定的对象

11.如果有多个类都需要某个类里的方法时，就使用继承，哪个类需要什么方法，这个类就调用父类什么方法，不必再自己写

12.给二维数组赋值时，要指定一维和二维的长度，然后用[i] = xxx.xx(i)   [j] = xx.xxx(j)来赋值

13.junit参数化测试方法：
在测试类上指定@RunWith(Parameterized.class)
然后设置需要用到的参数，并私有化，创建构造方法并赋值。
再创建静态的参数方法，指定@Parameterized.Parameters，以集合的形式返回(Collection)，return Array.asList(二维数组)

14.Optional是Java8提供的为了解决null安全问题的一个API（http://wkee.net/post/12828.html）
使用Optional，就可以把下面这样的代码进行改写。
public static String getName(User u) {
    if (u == null)
        return "Unknown";
    return u.name;
}

public static String getName(User u) {
    return Optional.ofNullable(u)
                    .map(user->user.name)
                    .orElse("Unknown");
}

15.linux命令：
重启:reboot
配置环境变量: su root   gedit ~/.bashrc 或者 gedit /etc/profile
解压: tar -zxvf XXXXX
转移文件: mv XXX   XXXX
创建文件夹: mkdir XXXX(-p为递归创建)
删除文件: rm -f XXXX  
删除文件夹（递归）: rm -rf xxxxx
配置java环境变量，maven环境变量:
export JAVA_HOME=/usr/java/jdk1.8.0_144
export JRE_HOME=$JAVA_HOME/jre
export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export PATH=/opt/apache-maven-3.5.0/bin:$PATH
pwd：当前位置
cd ~：回到家目录
cd -：回到上次的目录
cd ..：进入上一级目录

16.elasticsearch安装教程：
 下载解压elasticsearch
 安装node npm
 sudo ln -s /opt/node-v4.4.4-linux-x64/bin/node /usr/local/bin/node 
 sudo ln -s /opt/node-v4.4.4-linux-x64/bin/npm /usr/local/bin/npm
 运行./bin/elasticsearch
 下载head插件
 修改，/config/elasticsearch.yml 
 http.cors.enabled: true
 http.cors.allow-origin: "*"

17.ubuntu安装docker：
1. sudo wget -qO- https://get.docker.com/ | sh
2. sudo usermod -aG docker hsy

docker pull 拉取镜像
docker build 创建镜像
docker images 列出所有的镜像
docker run XXX  运行XXX镜像
docker ps  列出container
docker ps -a  查看所有的镜像包括已停止的
docker stop (image的id) 停止某个正在运行的镜像
docker commit -m '' 保存镜像里的改动
docker rmi  (image的id) 删除某个镜像
docker rm (image的id) 删除ps里的镜像
docker cp 在host和container之间拷贝文件

touch Dockerfile 创建dockerfile
docker file语法：
FROM 基础镜像
RUN 执行命令
ADD 添加文件
COPY 拷贝文件
CMD 执行命令
EXPOSE 暴露端口
WORKDIR 指定路径
MAINTAINER 维护者
ENV 设定环境变量
ENTRYPOINT 容器入口
USER 指定用户
VOLUME 容器挂载的卷

18.idea创建spring mvc项目
加载applicationContext.xml：ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
idea创建Resources文件夹，将applicationContext.xml，web.xml放入里面

19.ApplictionContext接口实现：
FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径
ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。
WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean

20.Java中sleep,wait,yield,join的区别
    1.sleep()方法在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。sleep()使当前线程进入阻塞状态，在指定时间内不会执行。

    2.wait()方法：在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。

    3.yield方法：暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。 

    4.join方法：等待该线程终止。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。

1.参数的类型不同，个数不同，在不改动代码结构的前提下，通过将某个参数的类型转换成需要的类型即可

2.hashmap是无序的

3.构造方法通过builder模式来创建，比写多个构造方法要更高效
方法：一个要执行的类，里面包含私有属性，并创建私有的构造方法（赋值），其中构造方法里传入外部类的实例对象，再创建一个内部静态类,定义外部类的实例，并创建静态内部类的public构造方法，并在构造方法里实例化外部类的实例，在构造方法里定义需要每次调用必须传的对象，给外部类的实例对象属性赋值，再创建后续需要调用的方法，最后在内部类创建类型为外部类的public build方法，返回值为外部类对象，并传入外部类的实例

4.
String：字符串常量

StringBuffer：字符串变量

StringBuilder：字符串变量
StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。
StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。StringBuilder是线程不安全的
执行速度方面的比较：StringBuilder >  StringBuffer  >  String

5.File[]数组里，要存放file应该以new File(path)

6.程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成

在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成

7.字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！
如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点
在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。

8.excel的操作用
<dependency>
 <groupId>org.apache.poi</groupId>
 <artifactId>poi</artifactId>
 <version>3.17-beta1</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml -->
<dependency>
 <groupId>org.apache.poi</groupId>
 <artifactId>poi-ooxml</artifactId>
 <version>3.17-beta1</version>
</dependency>
这两个lib
基本的操作：
File file = new File(System.getProperty("user.dir") + "\\src\\main\\java\\com\\hsy\\case\\" + casePath);
FileInputStream fileInputStream = new FileInputStream(file);
XSSFWorkbook xssfWorkbook = new XSSFWorkbook(fileInputStream);
xssfWorkbook.getSheetAt(i)这个返回当前的sheet
xssfWorkbook.getSheetAt(i).getLastRowNum()返回当前sheet的总行数
xssfWorkbook.getSheetAt(i).getLastRowNum(j).getCell(k)返回第j行第k个单元格的值
在操作单元格的时候，会因为单元格为空出现NullPointException，加入判断cell == null就好

9.static关键字的作用：修饰变量，常量，方法，代码块，静态内部类，静态包导入。
其中，静态代码块：JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次
静态代码块优先于构造函数执行

10.ArrayList：
底层是数组实现；
3种构造方法
在添加时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容

ArrayList不是线程安全的，只能用在单线程环境下，同样的实现Vector的方法前加了关键字synchronized
多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，List list = Collections.synchronizedList(new ArrayList());

Vector和Collections.synchronizedList区别：
（1）Vector比Collections.synchronizedList快了一点，SynchronizedList<E>类使用了委托(delegation)，实质上存储还是使用了构造时传进来的list，只是将list作为底层存储，对它做了一层包装
（2）SynchronizedList的同步，使用的是synchronized代码块对mutex对象加锁，这个mutex对象还能够通过构造函数传进来，也就是说我们可以指定锁定的对象
而Vector则使用了synchronized方法，同步方法的作用范围是整个方法，所以没办法对同步进行细粒度的控制。而且同步方法加锁的是this对象，没办法控制锁定的对象

11.如果有多个类都需要某个类里的方法时，就使用继承，哪个类需要什么方法，这个类就调用父类什么方法，不必再自己写

12.给二维数组赋值时，要指定一维和二维的长度，然后用[i] = xxx.xx(i)   [j] = xx.xxx(j)来赋值

13.junit参数化测试方法：
在测试类上指定@RunWith(Parameterized.class)
然后设置需要用到的参数，并私有化，创建构造方法并赋值。
再创建静态的参数方法，指定@Parameterized.Parameters，以集合的形式返回(Collection)，return Array.asList(二维数组)

14.Optional是Java8提供的为了解决null安全问题的一个API（http://wkee.net/post/12828.html）
使用Optional，就可以把下面这样的代码进行改写。
public static String getName(User u) {
    if (u == null)
        return "Unknown";
    return u.name;
}

public static String getName(User u) {
    return Optional.ofNullable(u)
                    .map(user->user.name)
                    .orElse("Unknown");
}

15.linux命令：
重启:reboot
配置环境变量: su root   gedit ~/.bashrc 或者 gedit /etc/profile
解压: tar -zxvf XXXXX
转移文件: mv XXX   XXXX
创建文件夹: mkdir XXXX(-p为递归创建)
删除文件: rm -f XXXX  
删除文件夹（递归）: rm -rf xxxxx
配置java环境变量，maven环境变量:
export JAVA_HOME=/usr/java/jdk1.8.0_144
export JRE_HOME=$JAVA_HOME/jre
export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export PATH=/opt/apache-maven-3.5.0/bin:$PATH
pwd：当前位置
cd ~：回到家目录
cd -：回到上次的目录
cd ..：进入上一级目录
